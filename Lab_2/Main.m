% Реализовать пакетную передачу данных между двумя HackRF.
%
% Формат данных: текстовая информация.
%
% Параметры системы передачи:
%   1. QPSK модуляция;
%   2. Битовая скорость: 1 Мб/с;
%   3. Символьная скорость: 500 кБод;
%   4. Формирующий фильтр: RRC, beta = 0.35.
%
% Поля пакета:
%   1. Преамбула;
%   2. Номер пакета;
%   3. Количество пакетов;
%   4. Данные;
%   5. CRC;
%   6. Некоторые другие технические данные.
%
% Требования к обработке:
%   - Частотная и фазовая синхронизация (по преамбуле);
%   - Хорошие корреляционные свойства преамбулы;
% 
% Изучить про (м.б. полезно):
%   - CRC;
%   - Послед-ти Уолша, Голда; m-последовательности.
%
% Примечания:
%   - Делать паузы между пакетами;
%   - Эквалайзер не требуется;
% 
% Оценка частотной отстройки:
%   - Стабильность опорного генератора Hack RF составляет 20 ppm;
%   - Положим несущую частоту равной 500 МГц;
%   - Учитывая худший случай, максимальная частотная отстройка при приёме 
%   при неподвижных приёмнике и передатчике составляет 20 кГц.
%
% Принцип подстройки частоты и фазы по преамбуле:
%   - Выбрать последовательность, выполняющую роль преамбулы, и построить 
%   её тело неопределённости. Рассматривать частотные сдвиги до 20 кГц.
%   - Для обнаружения преамбулы построить банк фильтров, согласованных с
%   преамбулой при различных частотных сдвигах в диапазоне -20 до 20 кГц. К
%   примеру, если p(t) - сигнал преамбулы, то ИХ i-го СФ:
% 
%                       h_i(t) = k_i(T - t), 
% 
%   где k_i(t) = p(t) * exp(j * 2*pi * f_bank(i) * t), f_bank(i) - i-я 
%   частотная отстройка из диапазона. 
%   - Величина df = f_bank(i) - f_bank(i-1) влияет на точность оценки 
%   частотной отстройки; её следует выбрать таким образом, чтобы при
%   подстройке частоты сигнала по преамбуле максимальная ротация фазы,
%   вызванная неточностью оценки частотной отстройки, за период 
%   длительности пакета не превышала фиксированной величины. Выберем 
%   величину максимальной ротации фазы равной 10 градусов или pi/18.
%   - При обнаружении преамбулы оценка частотной отстройки равна f_bank,
%   соответствующей согласованному фильтру, на выходе которого
%   присутствовал максимальный по величине отклик на воздействие преамбулы.
%   - После определения частотной отстройки происходит подстройка частоты и
%   фазы сигнала путём домножения на комплексную экспоненту:
%
%               exp(-j * 2*pi*f_bank * t) * exp(-j * phi),
% 
%   где фаза phi выбирается из соображения, что начальная фаза преамбулы
%   известна априори.

clc; clear;
close all;
addpath('../Lib/');

%% Параметры моделирования
% Битовая скорость
    BitRate = 1e6;
% Параметры RRC
    beta = 0.5;
    span = 10;
    sps = 20;
% Число передаваемых в пакете бит
    BitsPerPackage = 1024;
% Длина синхропоследовательности
    PreambleLen = 2^7 - 1;
% Нужно ли сохранять отсчёты сигнала в файл
    NeedSaveTxSignal = 0;
% Отстройка частоты и фазы сигнала
    fOffset = (40e3*rand() - 20e3) * 0;
    phiOffset = 2*pi*rand() - pi;
% Отношение энергии бита к дисперсии шума, дБ
    EbNo = 10;
% Энергия бита (QPSK)
    Eb = 1 / log2(4);

% Вычисляемые параметры
    % Символьная скорость (QPSK)
        BaudRate = BitRate / 2;
    % Частота дискретизации
        Fs = BaudRate * sps;
    % Период дискретизации
        Ts = 1/Fs;
    % RRC импульс
        RRC = rcosdesign(beta, span, sps);
    % Дисперсия шума
        No = Eb / 10^(EbNo/10);


%% Формирование пакета
% Генерация бит
    InputData = randi([0 1], BitsPerPackage, 1);
% Маппинг бит
    Symbols = pskmod(InputData, 4, pi/4, "gray", "InputType", "bit");
% Синхропоследовательность
    SyncSeq = (1 + 1j) * mlseq(PreambleLen);

% Объединение символов информационной последовательности и
% синхропоследовательности
    SymbolsPackage = [SyncSeq; Symbols];

% Формирование сигнала
    SymbolsPackageUpsampled = upsample(SymbolsPackage, sps);
    TxSignal = conv(SymbolsPackageUpsampled(1:end-(sps-1)), RRC);

% Сохранение сигнала в файл
    if NeedSaveTxSignal
        % Повышение частоты дискретизации до рабочей в SDR
            if Fs < 10e6
                FreqOffsetInd = ResamplingFun(TxSignal, Fs, 10e6);
            else
                FreqOffsetInd = TxSignal;
            end

        IQ2BinInt8(FreqOffsetInd, '.\..\Records\Lab_2_TxSig.bin');
        clear FreqOffsetInd;
    end

%% Канал передачи
% Добавление нулей до и после пакета
    RxSignal = [zeros(size(TxSignal)); TxSignal; zeros(size(TxSignal))];

% Добавление частотной отстройки и случайной фазы
    RxSignal = RxSignal .* ...
        exp(1j*2*pi*fOffset * (0:length(RxSignal)-1).' * Ts);
    RxSignal = RxSignal * exp(1j * phiOffset);

% Добавление АБГШ
    % Генерация комплексного шума
        Noise = randn(length(RxSignal), 2) * [1; 1j];
        Noise = Noise * sqrt(No/2);

    RxSignal = RxSignal + Noise;

%% Приём и обработка пакета
% Согласованная фильтрация
    FSignal = conv(RxSignal, RRC);

% Поиск НОМЕРА ОТСЧЁТА СИГНАЛА, С КОТОРОГО НАЧИНАЕТСЯ ПАКЕТ
    % Сетка частотных отстроек
        fVals = (0:3480:20e3);
        fVals = [fliplr(-fVals(2:end)) fVals];

    % Набор опорных последовательностей с разными частотными сдвигами
        RefSeqs = zeros(length(SyncSeq) * sps, length(fVals));

        for i = 1:length(fVals)
            RefSeqs(:, i) = upsample(SyncSeq, sps) .* ...
                exp(1j*2*pi*fVals(i) * (0:length(SyncSeq)*sps-1)' * Ts);
        end
        
    % Корреляция принятого сигнала с опорными последовательностями
        corrRes = zeros(length(FSignal)-size(RefSeqs, 1)+1, length(fVals));

        for i = 1:length(fVals)
            corrRes(:, i) = ...
                conv(FSignal, flipud(conj(RefSeqs(:, i))), "valid");
        end

    [MaxAbs, Inds] = max(abs(corrRes));
    [~, FreqOffsetInd] = max(MaxAbs);
    
    PackageBeginSample = Inds(FreqOffsetInd);

% Грубая частотная подстройка сигнала
    SignalTuned1 = FSignal .* ...
        exp(1j*2*pi*fVals(FreqOffsetInd) * (0:length(FSignal)-1)' * Ts);

% Синхронизация начала пакета по первому отсчёту переменной
    SignalSync = SignalTuned1(PackageBeginSample:end);

% Выбор модуляционных символов 
    RxPackageSymbols= SignalSync(1:sps:sps*(PreambleLen+BitsPerPackage/2));

% Точная частотная синхронизация
    % Принятая синхропоследовательность после грубой подстройки частоты
        RxPreample = RxPackageSymbols(1:127);
    
